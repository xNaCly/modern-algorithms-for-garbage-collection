// Go
    @online{go-escape,
        title={Escape analysis},
        url={https://cs.opensource.google/go/go/+/master:src/cmd/compile/internal/escape/escape.go},
        urldate={2023-11-06},
        year={2018},
        author={{The Go Authors}}
    }
    @online{go_gcguide_2022, 
        title = {A Guide to the Go Garbage Collector},
        url = {https://tip.golang.org/doc/gc-guide},
        urldate = {2023-10-09},
        year = {2022}
    }

    @online{go_spec_2023, 
        title = {The Go Programming Language Specification},
        url = {https://tip.golang.org/ref/spec},
        urldate = {2023-10-11},
        year = {2023}
    }

    @online{go_gckeynote_2018, 
        title = {Getting to Go: The Journey of Go's Garbage Collector},
        url = {https://go.dev/blog/ismmkeynote},
        urldate = {2023-10-09},
        year = {2018}
    }

// gc 
    // multiprocessor reference couting
    @article{gc-on-the-fly_2006,
        title={An on-the-fly reference-counting garbage collector for java},
        url={https://dl.acm.org/doi/pdf/10.1145/1111596.1111597},
        author={Levanoni, Yossi and Petrank, Erez},
        journal={ACM Transactions on Programming Languages and Systems (TOPLAS)},
        volume={28},
        number={1},
        pages={1--69},
        year={2006},
        publisher={ACM New York, NY, USA}
    }

    // generational scavenging
    @article{gc-generational-scavenging_1984,
        title={Generation scavenging: A non-disruptive high performance storage reclamation algorithm},
        url={https://dl.acm.org/doi/pdf/10.1145/390011.808261},
        author={Ungar, David},
        journal={ACM Sigplan notices},
        volume={19},
        number={5},
        pages={157--167},
        year={1984},
        publisher={ACM New York, NY, USA}
    }

    // reference counting
    @inproceedings{gc-references_2021,
        title={Perceus: Garbage free reference counting with reuse},
        url={https://xnning.github.io/papers/perceus.pdf},
        author={Reinking, Alex and Xie, Ningning and de Moura, Leonardo and Leijen, Daan},
        booktitle={Proceedings of the 42nd ACM SIGPLAN International Conference on Programming Language Design and Implementation},
        pages={96--111},
        year={2021}
    }

    // multi process gc
    @article{gc-multiprocess_1975,
        author = {Steele, Guy L.},
        title = {Multiprocessing Compactifying Garbage Collection},
        year = {1975},
        issue_date = {Sept. 1975},
        publisher = {Association for Computing Machinery},
        address = {New York, NY, USA},
        volume = {18},
        number = {9},
        issn = {0001-0782},
        url = {https://doi.org/10.1145/361002.361005},
        doi = {10.1145/361002.361005},
        abstract = {Algorithms for a multiprocessing compactifying garbage collector are presented and discussed. The simple case of two processors, one performing LISP-like list operations and the other performing garbage collection continuously, is thoroughly examined. The necessary capabilities of each processor are defined, as well as interprocessor communication and interlocks. Complete procedures for garbage collection and for standard list processing primitives are presented and thoroughly explained. Particular attention is given to the problems of marking and relocating list cells while another processor may be operating on them. The primary aim throughout is to allow the list processor to run unimpeded while the other processor reclaims list storage The more complex case involving several list processors and one or more garbage collection processors are also briefly discussed.},
        journal = {Commun. ACM},
        month = {sep},
        pages = {495–508},
        numpages = {14},
        keywords = {parallel processing, data structures, garbage collection, multiprocessing, relocation, compactification, storage allocation, free storage, LISP, semaphores, reclaimer, list processing, pointers, synchronization, gc processor, storage reclamation}
    }

    // gc with hardware support
    @inproceedings{gc-hardware_2018,
      title={A hardware accelerator for tracing garbage collection},
      author={Maas, Martin and Asanovi{\'c}, Krste and Kubiatowicz, John},
      url={https://people.eecs.berkeley.edu/~krste/papers/GC-MicroTopPicks2019.pdf},
      booktitle={2018 ACM/IEEE 45th Annual International Symposium on Computer Architecture (ISCA)},
      pages={138--151},
      year={2018},
      organization={IEEE}
    }

    // learned gc
    @inproceedings{learned-gc_2020,
      title={Learned garbage collection},
      author={Cen, Lujing and Marcus, Ryan and Mao, Hongzi and Gottschlich, Justin and Alizadeh, Mohammad and Kraska, Tim},
      booktitle={Proceedings of the 4th ACM SIGPLAN International Workshop on Machine Learning and Programming Languages},
      pages={38--44},
      year={2020}
    }

    // gc performance
    @article{gc-performance_2004,
      title={Myths and realities: The performance impact of garbage collection},
      url={https://users.cecs.anu.edu.au/~steveb/pubs/papers/mmtk-sigmetrics-2004.pdf},
      author={Blackburn, Stephen M and Cheng, Perry and McKinley, Kathryn S},
      journal={ACM SIGMETRICS Performance Evaluation Review},
      volume={32},
      number={1},
      pages={25--36},
      year={2004},
      publisher={ACM New York, NY, USA}
    }

    // age based / generational gc 
    @inproceedings{age-based-gc_1999,
      title={Age-based garbage collection},
      url={https://dl.acm.org/doi/pdf/10.1145/320384.320425},
      author={Stefanovi{\'c}, Darko and McKinley, Kathryn S and Moss, J Eliot B},
      booktitle={Proceedings of the 14th ACM SIGPLAN conference on Object-oriented Programming, Systems, Languages, and Applications},
      pages={370--381},
      year={1999}
    }

// gc 

// learned gc
@inproceedings{learned-gc_2020,
  title={Learned garbage collection},
  author={Cen, Lujing and Marcus, Ryan and Mao, Hongzi and Gottschlich, Justin and Alizadeh, Mohammad and Kraska, Tim},
  booktitle={Proceedings of the 4th ACM SIGPLAN International Workshop on Machine Learning and Programming Languages},
  pages={38--44},
  year={2020}
}

// gc performance
@article{gc-performance_2004,
  title={Myths and realities: The performance impact of garbage collection},
  url={https://users.cecs.anu.edu.au/~steveb/pubs/papers/mmtk-sigmetrics-2004.pdf},
  author={Blackburn, Stephen M and Cheng, Perry and McKinley, Kathryn S},
  journal={ACM SIGMETRICS Performance Evaluation Review},
  volume={32},
  number={1},
  pages={25--36},
  year={2004},
  publisher={ACM New York, NY, USA}
}

// age based / generational gc 
@inproceedings{age-based-gc_1999,
  title={Age-based garbage collection},
  url={https://dl.acm.org/doi/pdf/10.1145/320384.320425},
  author={Stefanovi{\'c}, Darko and McKinley, Kathryn S and Moss, J Eliot B},
  booktitle={Proceedings of the 14th ACM SIGPLAN conference on Object-oriented Programming, Systems, Languages, and Applications},
  pages={370--381},
  year={1999}
}

// ocaml
@online{ocmal_gc_unknown, 
    title = {Garbage Collection},
    url = {https://ocaml.org/docs/garbage-collection},
    urldate = {2023-10-09},
    year = {2023}
}

// Python
    @online{python-extending-gc_2008,
        title = {Extending and Embedding the Python Interpreter},
        url = {https://docs.python.org/release/2.5.2/ext/refcounts.html},
        urldate = {2023-11-06},
        year = {2008}
    }
    @online{python_gclib_2023, 
        title = {gc - Garbage Collector interface},
        url = {https://docs.python.org/3.13/library/gc.html},
        urldate = {2023-10-09},
        year = {2023}
    }

    @online{python_gcdesign_2023, 
        title = {Garbage collector design},
        url = {https://devguide.python.org/internals/garbage-collector/index.html},
        urldate = {2023-10-09},
        year = {2023}
    }

// Java
    @inproceedings{java_gc_full_analysis_2018,
        author = {Li, Haoyu and Wu, Mingyu and Chen, Haibo},
        title = {Analysis and Optimizations of Java Full Garbage Collection},
        year = {2018},
        isbn = {9781450360067},
        publisher = {Association for Computing Machinery},
        address = {New York, NY, USA},
        url = {https://doi.org/10.1145/3265723.3265735},
        doi = {10.1145/3265723.3265735},
        abstract = {Java runtime frees applications from manual memory management by its automatic garbage collection (GC), at the cost of stop-the-world pauses. State-of-the-art collectors leverage multiple generations, which will inevitably suffer from a full GC phase scanning the whole heap and induce a pause tens of times longer than normal collections, which largely affects both throughput and latency of the entire system. In this paper, we analyze the full GC performance of HotSpot Parallel Scavenge garbage collector comprehensively and study its algorithm design in depth. We find out that heavy dependencies among heap regions cause poor thread utilization. Furthermore, many heap regions contain mostly live objects (referred to as dense regions), which are unnecessary to collect. To solve these problems, we introduce two kinds of optimizations: allocating shadow regions dynamically as compaction destination to eliminate region dependencies and skipping dense regions to reduce GC workload. Evaluation results show the optimizations lead to averagely 2.6X (up to 4.5X) improvement in full GC throughput and thereby boost the application performance by 18.2\% on average (58.4\% at best).},
        booktitle = {Proceedings of the 9th Asia-Pacific Workshop on Systems},
        articleno = {18},
        numpages = {7},
        keywords = {Memory management, Parallel Scavenge, Full garbage collection, Performance, Java virtual machine},
        location = {Jeju Island, Republic of Korea},
        series = {APSys '18}
    }

    @inproceedings{java_gc_comparison_2019,
      author={Pufek, P. and Grgić, H. and Mihaljević, B.},
      booktitle={2019 42nd International Convention on Information and Communication Technology, Electronics and Microelectronics (MIPRO)}, 
      title={Analysis of Garbage Collection Algorithms and Memory Management in Java}, 
      year={2019},
      volume={},
      number={},
      pages={1677-1682},
      doi={10.23919/MIPRO.2019.8756844}
    }

    @online{java_language_spec_2023,
        url={https://docs.oracle.com/javase/specs/jls/se21/html/jls-1.html},
        title={Java Language Specification},
        year={2023},
        urldate={2023-10-19}
    }

    @online{java-util-scanner,
        url={https://docs.oracle.com/javase/8/docs/api/java/util/Scanner.html#close--},
        title={Class Scanner},
        year={2006},
        urldate={2023-10-19}
    }

// Rust / borrow checker
@article{rust_borrow_formalism_2021,
  doi = {10.1145/3443420},
  url = {https://doi.org/10.1145/3443420},
  year = {2021},
  month = mar,
  publisher = {Association for Computing Machinery ({ACM})},
  volume = {43},
  number = {1},
  pages = {1--73},
  author = {David J. Pearce},
  title = {A Lightweight Formalism for Reference Lifetimes and Borrowing in Rust},
  journal = {{ACM} Transactions on Programming Languages and Systems}
}

@book{rust_book_2019,
  title={The Rust Programming Language (Covers Rust 2018)},
  author={Klabnik, S. and Nichols, C.},
  isbn={9781718500440},
  month={Aug},
  year={2019},
  publisher={No Starch Press}
}

@online{rust_effective_borrow_checker,
    title={Effective Rust: Understanding the borrow checker},
    url={https://www.lurklurk.org/effective-rust/borrows.html},
    urldate={2023-11-09},
    year={2023},
    author={David Drysdale}
}

@oneline{rust_gc_removal,
    title={Removing Garbage Collection From the Rust Language},
    url={https://web.archive.org/web/20230911102334/https://pcwalton.github.io/_posts/2013-06-02-removing-garbage-collection-from-the-rust-language.html},
    urldate={2023-11-13},
    year={2013},
    author={Patrick Walton}
}

// Provided paper
@inproceedings{garbage_first_gc_2004,
  doi = {10.1145/1029873.1029879},
  url = {https://doi.org/10.1145/1029873.1029879},
  year = {2004},
  month = oct,
  publisher = {{ACM}},
  author = {David Detlefs and Christine Flood and Steve Heller and Tony Printezis},
  title = {Garbage-first garbage collection},
  booktitle = {Proceedings of the 4th international symposium on Memory management}
}

// call stack
@online{call-stack_mcmaster-memon_2006,
    title = {Call Stack Coverage for GUI Test-Suite Reduction},
    url = {https://www.cs.umd.edu/~atif/papers/McMasterMemonISSRE2006.pdf},
    urldate = {2023-10-11},
    year = {2006}
}

// static and dynamic scope
@online{static-dynamic-scope_tanter_2009,
    title = {Beyond static and dynamic scope},
    url = {https://dl.acm.org/doi/abs/10.1145/1837513.1640137},
    urldate = {2023-10-11},
    year = {2009}
}

// memory leak
@inproceedings{practical_heine-lam_2003,
  title={A practical flow-sensitive and context-sensitive C and C++ memory leak detector},
  author={Heine, David L and Lam, Monica S},
  booktitle={Proceedings of the ACM SIGPLAN 2003 conference on Programming language design and implementation},
  pages={168--181},
  year={2003}
}

// owasp

    // memory leak
    @online{owasp-memoryleak_unknown_unknown,
        title = {Memory leak},
        url = {https://owasp.org/www-community/vulnerabilities/Memory_leak},
        urldate = {2023-10-12},
        year = {2020}
    }

    // use after free
    @online{owasp-use-after-free_unkown_unknown,
        title = {Using freed memory},
        url = {https://owasp.org/www-community/vulnerabilities/Using_freed_memory},
        urldate = {2023-10-12},
        year = {2020}
    }

// tracing garbage collection
@inproceedings{tracing-gc_barabash_2010,
  title={Tracing garbage collection on highly parallel platforms},
  author={Barabash, Katherine and Petrank, Erez},
  url={https://web.archive.org/web/20150131070633id_/http://www.cs.technion.ac.il:80/~erez/Papers/parallel-trace-ismm.pdf},
  booktitle={Proceedings of the 2010 International Symposium on Memory management},
  pages={1--10},
  year={2010}
}
