// Go
    @online{go-escape,
        title={Escape analysis},
        url={https://cs.opensource.google/go/go/+/master:src/cmd/compile/internal/escape/escape.go},
        urldate={2023-11-06},
        year={2018},
        author={{The Go Authors}}
    }
    @online{go_gcguide_2022, 
        title = {A Guide to the Go Garbage Collector},
        url = {https://tip.golang.org/doc/gc-guide},
        urldate = {2023-10-09},
        year = {2022}
    }

    @article{dijkstra-gc-1978,
        author = {Dijkstra, Edsger W. and Lamport, Leslie and Martin, A. J. and Scholten, C. S. and Steffens, E. F. M.},
        title = {On-the-Fly Garbage Collection: An Exercise in Cooperation},
        year = {1978},
        issue_date = {Nov. 1978},
        publisher = {Association for Computing Machinery},
        address = {New York, NY, USA},
        volume = {21},
        number = {11},
        issn = {0001-0782},
        url = {https://doi.org/10.1145/359642.359655},
        doi = {10.1145/359642.359655},
        abstract = {As an example of cooperation between sequential processes with very little mutual interference despite frequent manipulations of a large shared data space, a technique is developed which allows nearly all of the activity needed for garbage detection and collection to be performed by an additional processor operating concurrently with the processor devoted to the computation proper. Exclusion and synchronization constraints have been kept as weak as could be achieved; the severe complexities engendered by doing so are illustrated.},
        journal = {Commun. ACM},
        month = {nov},
        pages = {966–975},
        numpages = {10},
        keywords = {program correctness for multiprogramming tasks, multiprocessing, fine-grained interleaving, cooperation bet. sequential processes w/ minimized mutual ex, garbage collection}
    }

    @online{go_spec_2023, 
        title = {The Go Programming Language Specification},
        url = {https://tip.golang.org/ref/spec},
        urldate = {2023-10-11},
        year = {2023}
    }

    @online{go_gckeynote_2018, 
        title = {Getting to Go: The Journey of Go's Garbage Collector},
        url = {https://go.dev/blog/ismmkeynote},
        urldate = {2023-10-09},
        year = {2018}
    }

// gc 
    // multiprocessor reference couting
    @article{gc-on-the-fly_2006,
        title={An on-the-fly reference-counting garbage collector for java},
        url={https://dl.acm.org/doi/pdf/10.1145/1111596.1111597},
        author={Levanoni, Yossi and Petrank, Erez},
        journal={ACM Transactions on Programming Languages and Systems (TOPLAS)},
        volume={28},
        number={1},
        pages={1--69},
        year={2006},
        publisher={ACM New York, NY, USA}
    }

    // generational scavenging
    @article{gc-generational-scavenging_1984,
        title={Generation scavenging: A non-disruptive high performance storage reclamation algorithm},
        url={https://dl.acm.org/doi/pdf/10.1145/390011.808261},
        author={Ungar, David},
        journal={ACM Sigplan notices},
        volume={19},
        number={5},
        pages={157--167},
        year={1984},
        publisher={ACM New York, NY, USA}
    }

    // reference counting
    @inproceedings{gc-references_2021,
        title={Perceus: Garbage free reference counting with reuse},
        url={https://xnning.github.io/papers/perceus.pdf},
        author={Reinking, Alex and Xie, Ningning and de Moura, Leonardo and Leijen, Daan},
        booktitle={Proceedings of the 42nd ACM SIGPLAN International Conference on Programming Language Design and Implementation},
        pages={96--111},
        year={2021}
    }

    // multi process gc
    @article{gc-multiprocess_1975,
        author = {Steele, Guy L.},
        title = {Multiprocessing Compactifying Garbage Collection},
        year = {1975},
        issue_date = {Sept. 1975},
        publisher = {Association for Computing Machinery},
        address = {New York, NY, USA},
        volume = {18},
        number = {9},
        issn = {0001-0782},
        url = {https://doi.org/10.1145/361002.361005},
        doi = {10.1145/361002.361005},
        abstract = {Algorithms for a multiprocessing compactifying garbage collector are presented and discussed. The simple case of two processors, one performing LISP-like list operations and the other performing garbage collection continuously, is thoroughly examined. The necessary capabilities of each processor are defined, as well as interprocessor communication and interlocks. Complete procedures for garbage collection and for standard list processing primitives are presented and thoroughly explained. Particular attention is given to the problems of marking and relocating list cells while another processor may be operating on them. The primary aim throughout is to allow the list processor to run unimpeded while the other processor reclaims list storage The more complex case involving several list processors and one or more garbage collection processors are also briefly discussed.},
        journal = {Commun. ACM},
        month = {sep},
        pages = {495–508},
        numpages = {14},
        keywords = {parallel processing, data structures, garbage collection, multiprocessing, relocation, compactification, storage allocation, free storage, LISP, semaphores, reclaimer, list processing, pointers, synchronization, gc processor, storage reclamation}
    }

    // gc with hardware support
    @inproceedings{gc-hardware_2018,
      title={A hardware accelerator for tracing garbage collection},
      author={Maas, Martin and Asanovi{\'c}, Krste and Kubiatowicz, John},
      url={https://people.eecs.berkeley.edu/~krste/papers/GC-MicroTopPicks2019.pdf},
      booktitle={2018 ACM/IEEE 45th Annual International Symposium on Computer Architecture (ISCA)},
      pages={138--151},
      year={2018},
      organization={IEEE}
    }

    // learned gc
    @inproceedings{learned-gc_2020,
      title={Learned garbage collection},
      author={Cen, Lujing and Marcus, Ryan and Mao, Hongzi and Gottschlich, Justin and Alizadeh, Mohammad and Kraska, Tim},
      booktitle={Proceedings of the 4th ACM SIGPLAN International Workshop on Machine Learning and Programming Languages},
      pages={38--44},
      year={2020}
    }

    // gc performance
    @article{gc-performance_2004,
      title={Myths and realities: The performance impact of garbage collection},
      url={https://users.cecs.anu.edu.au/~steveb/pubs/papers/mmtk-sigmetrics-2004.pdf},
      author={Blackburn, Stephen M and Cheng, Perry and McKinley, Kathryn S},
      journal={ACM SIGMETRICS Performance Evaluation Review},
      volume={32},
      number={1},
      pages={25--36},
      year={2004},
      publisher={ACM New York, NY, USA}
    }

    // age based / generational gc 
    @inproceedings{age-based-gc_1999,
      title={Age-based garbage collection},
      url={https://dl.acm.org/doi/pdf/10.1145/320384.320425},
      author={Stefanovi{\'c}, Darko and McKinley, Kathryn S and Moss, J Eliot B},
      booktitle={Proceedings of the 14th ACM SIGPLAN conference on Object-oriented Programming, Systems, Languages, and Applications},
      pages={370--381},
      year={1999}
    }

// gc 

// learned gc
@inproceedings{learned-gc_2020,
  title={Learned garbage collection},
  author={Cen, Lujing and Marcus, Ryan and Mao, Hongzi and Gottschlich, Justin and Alizadeh, Mohammad and Kraska, Tim},
  booktitle={Proceedings of the 4th ACM SIGPLAN International Workshop on Machine Learning and Programming Languages},
  pages={38--44},
  year={2020}
}

// gc performance
@article{gc-performance_2004,
  title={Myths and realities: The performance impact of garbage collection},
  url={https://users.cecs.anu.edu.au/~steveb/pubs/papers/mmtk-sigmetrics-2004.pdf},
  author={Blackburn, Stephen M and Cheng, Perry and McKinley, Kathryn S},
  journal={ACM SIGMETRICS Performance Evaluation Review},
  volume={32},
  number={1},
  pages={25--36},
  year={2004},
  publisher={ACM New York, NY, USA}
}

// age based / generational gc 
@inproceedings{age-based-gc_1999,
  title={Age-based garbage collection},
  url={https://dl.acm.org/doi/pdf/10.1145/320384.320425},
  author={Stefanovi{\'c}, Darko and McKinley, Kathryn S and Moss, J Eliot B},
  booktitle={Proceedings of the 14th ACM SIGPLAN conference on Object-oriented Programming, Systems, Languages, and Applications},
  pages={370--381},
  year={1999}
}

// ocaml
@online{ocmal_gc_unknown, 
    title = {Garbage Collection},
    url = {https://ocaml.org/docs/garbage-collection},
    urldate = {2023-10-09},
    year = {2023}
}

// Python
    @online{python-extending-gc_2008,
        title = {Extending and Embedding the Python Interpreter},
        url = {https://docs.python.org/release/2.5.2/ext/refcounts.html},
        urldate = {2023-11-06},
        year = {2008}
    }
    @online{python_gclib_2023, 
        title = {gc - Garbage Collector interface},
        url = {https://docs.python.org/3.13/library/gc.html},
        urldate = {2023-10-09},
        year = {2023}
    }

    @online{python_gcdesign_2023, 
        title = {Garbage collector design},
        url = {https://devguide.python.org/internals/garbage-collector/index.html},
        urldate = {2023-10-09},
        year = {2023}
    }

// Java
    @inproceedings{java_gc_full_analysis_2018,
        author = {Li, Haoyu and Wu, Mingyu and Chen, Haibo},
        title = {Analysis and Optimizations of Java Full Garbage Collection},
        year = {2018},
        isbn = {9781450360067},
        publisher = {Association for Computing Machinery},
        address = {New York, NY, USA},
        url = {https://doi.org/10.1145/3265723.3265735},
        doi = {10.1145/3265723.3265735},
        abstract = {Java runtime frees applications from manual memory management by its automatic garbage collection (GC), at the cost of stop-the-world pauses. State-of-the-art collectors leverage multiple generations, which will inevitably suffer from a full GC phase scanning the whole heap and induce a pause tens of times longer than normal collections, which largely affects both throughput and latency of the entire system. In this paper, we analyze the full GC performance of HotSpot Parallel Scavenge garbage collector comprehensively and study its algorithm design in depth. We find out that heavy dependencies among heap regions cause poor thread utilization. Furthermore, many heap regions contain mostly live objects (referred to as dense regions), which are unnecessary to collect. To solve these problems, we introduce two kinds of optimizations: allocating shadow regions dynamically as compaction destination to eliminate region dependencies and skipping dense regions to reduce GC workload. Evaluation results show the optimizations lead to averagely 2.6X (up to 4.5X) improvement in full GC throughput and thereby boost the application performance by 18.2\% on average (58.4\% at best).},
        booktitle = {Proceedings of the 9th Asia-Pacific Workshop on Systems},
        articleno = {18},
        numpages = {7},
        keywords = {Memory management, Parallel Scavenge, Full garbage collection, Performance, Java virtual machine},
        location = {Jeju Island, Republic of Korea},
        series = {APSys '18}
    }

    @inproceedings{java_gc_comparison_2019,
        author={Pufek, P. and Grgić, H. and Mihaljević, B.},
        booktitle={2019 42nd International Convention on Information and Communication Technology, Electronics and Microelectronics (MIPRO)}, 
        title={Analysis of Garbage Collection Algorithms and Memory Management in Java}, 
        year={2019},
        volume={},
        number={},
        pages={1677-1682},
        doi={10.23919/MIPRO.2019.8756844}
    }

     @inproceedings{java_gc_comparison_2018,
        author={Grgic, H. and Mihaljević, B. and Radovan, A.},
        booktitle={2018 41st International Convention on Information and Communication Technology, Electronics and Microelectronics (MIPRO)}, 
        title={Comparison of garbage collectors in Java programming language}, 
        year={2018},
        volume={},
        number={},
        pages={1539-1544},
        doi={10.23919/MIPRO.2018.8400277}
    }

    @online{java_language_spec_2023,
        url={https://docs.oracle.com/javase/specs/jls/se21/html/jls-1.html},
        title={Java Language Specification},
        year={2023},
        urldate={2023-10-19}
    }

    @online{java-util-scanner,
        url={https://docs.oracle.com/javase/8/docs/api/java/util/Scanner.html#close--},
        title={Class Scanner},
        year={2006},
        urldate={2023-10-19}
    }

    @online{java_g1_getting_started,
        url={https://docs.oracle.com/en/java/javase/17/gctuning/garbage-first-g1-garbage-collector1.html},
        title={Getting Started with the G1 Garbage Collector},
        year={2021},
        urldate={2023-11-17}
    }

    @online{java_available_gcs,
        url={https://docs.oracle.com/javase/9/gctuning/available-collectors.htm},
        title={Java Virtual Machine Garbage Collection - Available Collectors},
        year={2017},
        author={{Oracle and/or its affiliates}},
        urlaccessdate={2023-11-20}
    }

    @inproceedings{java_g1_deconstruting_2020,
        author = {Zhao, Wenyu and Blackburn, Stephen M.},
        title = {Deconstructing the Garbage-First Collector},
        year = {2020},
        isbn = {9781450375542},
        publisher = {Association for Computing Machinery},
        address = {New York, NY, USA},
        url = {https://doi.org/10.1145/3381052.3381320},
        doi = {10.1145/3381052.3381320},
        abstract = {Garbage-First is among today's most widely used garbage collectors. It is used in the HotSpot and OpenJDK virtual machines, and shares algorithmic foundations with three other important contemporary collectors: Shenandoah, C4, and ZGC. However, the design of the core algorithms and the performance tradeoffs they manifest have not been carefully analyzed in the literature. In this work, we deconstruct the G1 algorithm and re-implement it from first principles. We retrospectively develop a concurrent, region-based evacuating collector, CRE, which captures the principal design elements shared by G1, Shenandoah, C4, and ZGC. We then evaluate the impact of each of the major elements of G1 on performance, including pause time, remembered set footprint and barrier overheads. We find that G1's concurrent marking and generational collection reduces the 95-percentile GC pauses by 64\% and 93\% respectively. We find that the space overhead of G1's remembered sets is very low, typically under 1\%. We also independently measure the barriers used by G1 and find that they have an overhead of around 12\% with respect to total performance. This analysis gives users and collector designers insights into the garbage-first collector and the other fixed-size region-based concurrent evacuating collectors, which we hope will lead to better use of the collectors and provoke future improvements.},
        booktitle = {Proceedings of the 16th ACM SIGPLAN/SIGOPS International Conference on Virtual Execution Environments},
        pages = {15–29},
        numpages = {15},
        keywords = {garbage collection, Java, memory management, concurrent garbage collection, barriers},
        location = {Lausanne, Switzerland},
        series = {VEE '20}
    }

    @inproceedings{java_g1_2004,
        author = {Detlefs, David and Flood, Christine and Heller, Steve and Printezis, Tony},
        title = {Garbage-First Garbage Collection},
        year = {2004},
        isbn = {1581139454},
        publisher = {Association for Computing Machinery},
        address = {New York, NY, USA},
        url = {https://doi.org/10.1145/1029873.1029879},
        doi = {10.1145/1029873.1029879},
        abstract = {Garbage-First is a server-style garbage collector, targeted for multi-processors with large memories, that meets a soft real-time goal with high probability, while achieving high throughput. Whole-heap operations, such as global marking, are performed concurrently with mutation, to prevent interruptions proportional to heap or live-data size. Concurrent marking both provides collection "completeness" and identifies regions ripe for reclamation via compacting evacuation. This evacuation is performed in parallel on multiprocessors, to increase throughput.},
        booktitle = {Proceedings of the 4th International Symposium on Memory Management},
        pages = {37–48},
        numpages = {12},
        keywords = {parallel garbage collection, soft real-time garbage collection, concurrent garbrage collection, garbage collection, garbage-first garbage collection},
        location = {Vancouver, BC, Canada},
        series = {ISMM '04}
    }

// Rust / borrow checker
@article{rust_borrow_formalism_2021,
  doi = {10.1145/3443420},
  url = {https://doi.org/10.1145/3443420},
  year = {2021},
  month = mar,
  publisher = {Association for Computing Machinery ({ACM})},
  volume = {43},
  number = {1},
  pages = {1--73},
  author = {David J. Pearce},
  title = {A Lightweight Formalism for Reference Lifetimes and Borrowing in Rust},
  journal = {{ACM} Transactions on Programming Languages and Systems}
}

@book{rust_book_2019,
  title={The Rust Programming Language (Covers Rust 2018)},
  author={Klabnik, S. and Nichols, C.},
  isbn={9781718500440},
  month={Aug},
  year={2019},
  publisher={No Starch Press}
}

@online{rust_effective_borrow_checker,
    title={Effective Rust: Understanding the borrow checker},
    url={https://www.lurklurk.org/effective-rust/borrows.html},
    urldate={2023-11-09},
    year={2023},
    author={David Drysdale}
}

@oneline{rust_gc_removal,
    title={Removing Garbage Collection From the Rust Language},
    url={https://web.archive.org/web/20230911102334/https://pcwalton.github.io/_posts/2013-06-02-removing-garbage-collection-from-the-rust-language.html},
    urldate={2023-11-13},
    year={2013},
    author={Patrick Walton}
}

@misc{rust_usability,
      title={The Usability of Ownership}, 
      author={Will Crichton},
      year={2021},
      eprint={2011.06171},
      archivePrefix={arXiv},
      primaryClass={cs.PL}
}

// Provided paper
@inproceedings{garbage_first_gc_2004,
  doi = {10.1145/1029873.1029879},
  url = {https://doi.org/10.1145/1029873.1029879},
  year = {2004},
  month = oct,
  publisher = {{ACM}},
  author = {David Detlefs and Christine Flood and Steve Heller and Tony Printezis},
  title = {Garbage-first garbage collection},
  booktitle = {Proceedings of the 4th international symposium on Memory management}
}

// call stack
@online{call-stack_mcmaster-memon_2006,
    title = {Call Stack Coverage for GUI Test-Suite Reduction},
    url = {https://www.cs.umd.edu/~atif/papers/McMasterMemonISSRE2006.pdf},
    urldate = {2023-10-11},
    year = {2006}
}

// static and dynamic scope
@online{static-dynamic-scope_tanter_2009,
    title = {Beyond static and dynamic scope},
    url = {https://dl.acm.org/doi/abs/10.1145/1837513.1640137},
    urldate = {2023-10-11},
    year = {2009}
}

// memory leak
@inproceedings{practical_heine-lam_2003,
  title={A practical flow-sensitive and context-sensitive C and C++ memory leak detector},
  author={Heine, David L and Lam, Monica S},
  booktitle={Proceedings of the ACM SIGPLAN 2003 conference on Programming language design and implementation},
  pages={168--181},
  year={2003}
}

// owasp

    // memory leak
    @online{owasp-memoryleak_unknown_unknown,
        title = {Memory leak},
        url = {https://owasp.org/www-community/vulnerabilities/Memory_leak},
        urldate = {2023-10-12},
        year = {2020}
    }

    // use after free
    @online{owasp-use-after-free_unkown_unknown,
        title = {Using freed memory},
        url = {https://owasp.org/www-community/vulnerabilities/Using_freed_memory},
        urldate = {2023-10-12},
        year = {2020}
    }

// tracing garbage collection
@inproceedings{tracing-gc_barabash_2010,
  title={Tracing garbage collection on highly parallel platforms},
  author={Barabash, Katherine and Petrank, Erez},
  url={https://web.archive.org/web/20150131070633id_/http://www.cs.technion.ac.il:80/~erez/Papers/parallel-trace-ismm.pdf},
  booktitle={Proceedings of the 2010 International Symposium on Memory management},
  pages={1--10},
  year={2010}
}
