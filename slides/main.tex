\documentclass{beamer}
\usepackage[ngerman]{babel}
\usepackage[utf8]{inputenc}
\usepackage{graphicx}
\usepackage{hyperref}
\usepackage{minted}
\usemintedstyle{perldoc}
\graphicspath{{./assets/}}
\setcounter{tocdepth}{1}

\title{Modern Algorithms for Garbage Collection}
\subtitle{Outlining modern algorithms for garbage collection on the examples of Go and Java}
\date[2023]{2023}
\author{9525469, 6424019} 

\institute[DHBW Mosbach]{DHBW Mosbach}

\date{\today}

\usetheme{metropolis}
\setbeamertemplate{navigation symbols}{}
\setbeamertemplate{footline}[frame number]
\setbeamertemplate{section in toc}[sections numbered]

\begin{document}
    
    \frame{\titlepage}
    \begin{frame}
        \tableofcontents
    \end{frame}

	\section{Garbage collection}
        \begin{frame}
            \frametitle{Garbage collection}

            Garbage collection ist definiert als

            \begin{itemize}
                \item Erkennung von nicht mehr verwendeten Speicherbereichen
                \item automatisches Entfernen dieser
            \end{itemize}

            Und zielt darauf ab das obige:

            \begin{itemize}
                \item schnell
                \item effizient
                \item mit wenig Latenz
                \item mit wenig RAM und CPU Auslastung
            \end{itemize}

            umzusetzen.
        \end{frame}

        \subsection{Garbage collection - Nutzen}
            \begin{frame}
                \frametitle{Garbage collection - Nutzen}

                Befreit den Programmierer zumeist von:
                \begin{itemize}
                    \item Manueller Speicherallokierung mit \texttt{malloc}, \texttt{calloc} und \texttt{realloc}
                    \item Manueller Speicherfreigabe mit \texttt{free}
                    \item Pointer arithmetik
                \end{itemize}

                Verhindert Fehler wie: \footnote{70\% der CVE's von Chromium sind Speicherzugriffbezogen, siehe: \href{https://www.chromium.org/Home/chromium-security/memory-safety/}{https://www.chromium.org/Home/chromium-security/memory-safety/}}
                \begin{itemize}
                    \item Seg faults (illegaler Speicherzugriff) 
                    \item Use after \texttt{free} (Speicherzugriff auf bereits aufgeräumte Speicherbereiche)
                    \item Memory leaks (Speicher wird nach Verwendung nicht freigegeben)
                \end{itemize}
            \end{frame}

        \subsection{Garbage collection - Problematiken}
            \begin{frame}
                \frametitle{Garbage collection - Problematiken}
                \begin{itemize}
                    \item Peformance schlechter im Vergleich zu manuellem
                        management und borrow checker
                        \begin{itemize}
                            \item Latenz 
                            \item RAM und CPU Verbrauch
                            \item Generational, Mark \& Sweep: Scannen vom Heap langsam
                            \item Reference counting: erhöhter Speicherverbrauch: 100 Objekte: $100*objektgroeße$ auf $100*(objektgroeße+countergroeße)$
                        \end{itemize}
                    \item Einfluss von GC-zyklen auf Program nicht vorhersehbar
                    \item Manuelle Allokationen mit Speicherarena effizienter
                        für große Datenmengen als jedes Objekt einzeln
                        allokieren
                \end{itemize}
            \end{frame}

    \section{Strategien}
        \begin{frame}
            \frametitle{Strategien}

            Strategien unterscheiden sich in ihrer:

            \begin{itemize}
                \item Erkennung von unerreichbaren Objekten
                \item Entfernung von unerreichbaren Objekten
                \item Latenz, RAM und CPU Verbrauch
            \end{itemize}
        \end{frame}

        \subsection{Mark \& Sweep}
            \begin{frame}
                \frametitle{Strategien - Mark \& Sweep}
                \begin{itemize}
                    \item Scannt den Heap anfangend von Root Objekten
                    \item markiert Objekte die am Leben sind
                    \item während obigem meist Stop the World
                    \item deallokiert alle Objekte die nicht als am Leben markiert sind
                \end{itemize}
            \end{frame}

            \begin{frame}
                \frametitle{Strategien - Mark \& Sweep}
                \includegraphics[width=\textwidth]{images/Mark_nd_Sweep.png}
            \end{frame}
        \subsection{Generational garbage collection}
            \begin{frame}
                \frametitle{Strategien - Generational garbage collection}
                Optimierung basierend auf der Beobachtung, dass die meisten Objekte nur kurzlebig sind (Infant Mortality)\\
                Aufteilung in drei Speicherbereiche aufgeteilt:
                \begin{itemize}
                    \item Young, bestehend aus Eden und Survivor Space
                    \item Old
                    \item Permanent
                \end{itemize}
                % Unterteilung des Heaps in die Generationen:
                % https://www.oracle.com/technetwork/tutorials/tutorials-1876574.html
                % https://www.oracle.com/webfolder/technetwork/tutorials/obe/java/G1GettingStarted/images/HeapStructure.png
                \includegraphics[width=\textwidth]{images/GenerationalGCHeapStructure.png}
            \end{frame}

            \begin{frame}
                \frametitle{Strategien - Generational garbage collection}
                \begin{itemize}
                    \item Eden
                    \begin{itemize}
                        \item Alle neuen Objekte werden hier allokiert
                        \item Objekte welche eine gewisse Zeit überleben werden in den Survivor Space verschoben
                    \end{itemize}
                    \item Survivor
                    \begin{itemize}
                        \item Hier sind Objekte welche eine gewisse Zeit überlebt haben
                        \item Objekte welche eine längere Zeit überlebt haben werden in den Old Space verschoben
                    \end{itemize}
                    \item Old
                    \begin{itemize}
                        \item Hier sind Objekte welche schon länger existieren und es unwahrscheinlich ist, dass sie bald gelöscht werden
                    \end{itemize}
                \end{itemize}
                Eden wird aufgrund von Infant Mortality häufig collected, ist aber klein da lang lebende Objekte nicht dort sind.
            \end{frame}

        \subsection{Reference counting}
            \begin{frame}
                \frametitle{Strategien - Reference counting}

                \begin{itemize}
                    \item Jedes Objekt hat einen Zähler, welcher die Anzahl der Referenzen auf das Objekt zählt.\\
                    \item Beim Erstellen eines Pointers auf das Objekt wird der Zähler inkrementiert, beim Löschen dekrementiert.\\
                    \item Wird der Zähler 0, so wird das Objekt deallokiert.
                \end{itemize}
                Probleme bei Referenzzyklen: Zähler wird nie 0, Objekte werden nicht gelöscht.
            \end{frame}

            \begin{frame}[fragile]
                \frametitle{Strategien - Reference counting}

                % https://github.com/python/cpython/blob/main/Include/object.h#L214
                    \begin{minted}{c}
struct PyObject {
    // ...
    uint32_t ob_ref_local;      // local reference count
    // ...
};
                    \end{minted}

                \includegraphics[width=\textwidth]{images/Reference-counting.png}
            \end{frame}


    \section{Programmiersprachen}
        \begin{frame}
            \frametitle{Programmiersprachen}

            \begin{itemize}
                \item Viele Sprachen mit und ohne GC
                \item Algorithmen, Implementierungen und Performance sehr unterschiedlich
                \item High level sprachen eher mit GC, low level eher ohne
            \end{itemize}
        \end{frame}

        \subsection{Ohne Garbage collection}
            \begin{frame}
                \frametitle{Programmiersprachen - Ohne gc}

                \begin{itemize}
                    \item C
                    \begin{itemize}
                        \item manuelles memory managment
                    \end{itemize}
                    \item C++
                    \begin{itemize}
                        \item manuelles memory managment
                        \item reference counting on demand
                    \end{itemize}
                    \item Rust
                    \begin{itemize}
                        \item borrow checker
                        \item reference counting on demand
                    \end{itemize}
                \end{itemize}
            \end{frame}

        \subsection{Mit Garbage collection}
            \begin{frame}
                \frametitle{Programmiersprachen - Mit gc}
                \begin{itemize}
                    \item Go
                    \begin{itemize}
                        \item escape analysis
                        \item mark \& sweep
                    \end{itemize}
                    \item Java
                    \begin{itemize}
                        \item mehrere garbage collectoren
                        \item generational standardmäßig
                        \item Compiliert in Bytecode(AOT), Ausführung mit Bytecode vm (JVM)
                    \end{itemize}
                    \item Python
                    \begin{itemize}
                        \item Reference counting
                        \item Erkennung von Referenzzyklen
                    \end{itemize}
                    \item JavaScript
                    \begin{itemize}
                        \item generational
                        \item JIT, Bytecode vm (V8)
                    \end{itemize}
                \end{itemize}
            \end{frame}

    \section{Implementierungen}
        \subsection{Go}
            \begin{frame}
                \frametitle{Implementierungen - Go}
            \end{frame}

        \subsection{Java}
            \begin{frame}
                \frametitle{Implementierungen - Java}
            \end{frame}

    \section{Performance}
        \begin{frame}
            \frametitle{Performance}

            Diverse Kriterien möglich, hier beschränkt auf:

            \begin{itemize}
                \item Speicherverbrauch: stärke RAM-Intensivität
                \item Latenz: Umfang Stoppzeiten des Programs
                \item Sicherheit: Speicherzugriffsicherheit
                \item Nutzbarkeit: Komplexität der Strategien
            \end{itemize}
        \end{frame}
        
    \section{Borrow Checking}

        \subsection{Theorie}
        \begin{frame}
            \frametitle{Borrow Checking - Theorie}

            \texttt{free} Calls können automatisch eingefügt werden, wenn der Compiler weiß wielange ein Objekt verwendet wird (\textit{Lifetime})\\
            $\Rightarrow$ automatisches Speichermanagement ohne GC\\
            Um dies möglich zu machen werden die Konzepte des \textit{Ownership} und \textit{Borrowing} eingeführt.
        \end{frame}

        \begin{frame}
            \frametitle{Borrow Checking - Ownership \& Borrowing}
            Ownership:
            \begin{itemize}
                \item Eine Variable hat einen Owner in Form einer Funktion
                \item Ownership kann von einer Funktion an eine andere übergeben werden (pass by value/return via moves)
            \end{itemize}
            Um auf Variablen an mehreren Stellen zugreifen zu können, kann diese geborrowed (verliehen) werden:
            \begin{itemize}
                \item Der Owner einer Variable kann $n$ lesende Referenzen(via Pointer) und eine schreibende Referenz an andere Orte verleihen
                \item Borrowing ist nur für einen bestimmten Zeitraum möglich (Lifetime)
                \item Borrows dürfen nicht über den Lifetime des Owners hinausgehen, sichergestellt durch den Borrow Checker
            \end{itemize}
        \end{frame}

        \subsection{Beispiel in Rust}
        \begin{frame}[fragile]
            \frametitle{Borrow Checking - Beispiel in Rust}

            \begin{minted}{rust}
use std::io::{self, Error};

fn main() -> Result<(), Error> {
    println!("Eingabe: ");
    let line = io::stdin().next();

    if let Some(line) = line {
        println!("Gelesene Eingabe: \"{}\"", line?);
    } else {
        println!("Keine Eingabe");
    }

    Ok(())
}
            \end{minted}
        \end{frame}

    \section{Fragen?}

\end{document}

