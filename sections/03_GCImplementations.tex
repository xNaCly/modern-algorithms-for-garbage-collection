\chapter{Garbage collected Programming Languages}

In this chapter, garbage collection implementations of two programming
languages are presented. Both make use of the theoretical concepts presented
in \autoref{sec:overview}.

\section{Go}

Go uses a tri-color, concurrent mark \& sweep garbage collector based on an
algorithm introduced by Dijkstra in 1978 \cite{dijkstra-gc-1978}. Mark \& sweep
garbage collection introduces the requirement of tracing all memory before any
memory can be released \cite[The GC cycle]{go_gcguide_2022} for there could
still be untraced pointers marking an object previously thought to be
unreachable as reachable. This segments the gc cycles into \textit{marking} and
\textit{sweeping} while also introducing the \textit{off} phase notating the
garbage collector as inactive while no GC related work is required.

\subsection{Detecting reachable objects}

As the name suggests and introduced in \autoref{sec:gc_mark_sweep}, the go
garbage collector determines whether or not an object is to be considered
reachable by starting from the root objects (see
\autoref{sec:categorizing_memory}) and scanning all following pointers and
objects.

As previously introduced, the employed algorithm for archiving this in an
efficient way is based upon the previous work by Dijkstra. This approach
revolves around three sets: the white set - all candidates for having their
memory recycled, the black set - all objects without references to the white
set and that are reachable from the roots, the grey set - objects reachable
from the roots not yet scanned for references to the white objects.

Using this, the algorithm considers all objects as white at the start of the
given garbage collection cycle and starts the following process:

\begin{enumerate}
    \item An object from the grey set is picked 
    \item Each white object it references to is moved to the grey set (neither
        the object nor all referenced objects can be garbage collected) 
    \item The current object is moved to the black set 
    \item Repeat previous steps until grey set is empty
\end{enumerate}

\subsection{Removing unreachable objects}

\subsection{Fine-tuning}

The go garbage collector can be tweaked to fine-tune the trade-off between the
garbage collectors CPU and its memory usage \cite[The GC
cycle]{go_gcguide_2022}. This can be done by invoking the go runtime with an
environment variable called \texttt{GOGC} \cite[GOGC]{go_gcguide_2022}.

\section{Java}

Java by default uses a generational garbage collector as introduced in
\autoref{sec:gc_generational}. This garbage collector is called Garbage First
(G1) and was made the default with Java 9 \cite{java_gc_comparison_2018}.
Before that, Java used various types of mark and sweep collectors
\cite{java_available_gcs}.

Beyond those there are many more garbage collectors available for Java that can
be used by specifying them as a command line argument to the JVM. These are not
relevant for this writing, as they are not used by default. Nonetheless these
can be very useful when wanting to use a garbage collector tuned to a specific
use case.

\subsection{Garbage First Collector introduction}

Contrary to the theoretical concept of a generational garbage collector,
the memory areas for each generation in G1GC are not continuous in memory.
Instead G1GC uses a heap divided into regions usually 1 MB - 32 MB in size.
Each region is assigned to one of the generations or unused.
These generations are called Eden, Survivor and Old. \cite{java_g1_getting_started}
An example heap layout with regions assigned to the generations is shown in \autoref{fig:g1_heap_layout}.

\begin{figure}[htbp]
    \centering
    \includegraphics[width=.7\textwidth]{images/G1_Heap_Layout.drawio.png}
    \caption{Heap layout of the G1 garbage collector}
    \label{fig:g1_heap_layout}
\end{figure}

Using constant sized regions instead of continuous memory areas has the advantage
that the heap does not need to be contiguous in memory for generational garbage collection to work.

\subsection{Allocating memory}

When a object is allocated onto the heap, it will be first allocated into the
Eden region inside of the Young generation as outlined in the theoretical concept
of generational garbage collection in \autoref{sec:gc_generational}.
One memory region is marked as the current allocation region.
New objects are allocated into this region until.
Once the region is full, it will be marked as full and a new currently unused region will be
chosen as the new allocation region \cite[2.1 Allocation]{java_g1_2004}.
If no free memory region is available, a new one will be allocated through the operating system.

Large objects are stored in their own regions, called humongous regions
and not inside the Young/Old generation regions.
This is done to simplify the garbage collection of large objects which
would cause problems when stored inside the Young/Old generation regions \cite[2.1 Heap Layout]{java_g1_2004}.

\subsection{Collecting memory from memory regions}

% TODO: compacting

\subsection{Realtime goal of G1}

G1 tries have low pause times for garbage collection improving the
responsiveness of the application and allow for usage in applications
requiring predictable pause times. However pause times are only goals
and there are no guarantees that they will be met
\cite[3.2 Satisfying a Soft Real-Time Goal]{java_g1_2004}.

It does this by estimating the amount of garbage in each region and
prioritizing regions with more garbage for collection, resulting in lower stop-the-world mark phases
compared to regions with less garbage. % TODO: source
Additionally it predicts how long a collection of a region will take and
limit the amount that is done in a garbage collection cycle to meet a
specified time goal \cite[3.2.1 Predicting Evacuation Pause Times]{java_g1_2004}.

The pause time goal and desired intervals for garbgage collection pauses can be configured using
JVM command line arguments \cite[Ergonomic Defaults for G1 GC]{java_g1_getting_started}.

% TODO: shenandoah mention?
