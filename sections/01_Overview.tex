\chapter{Garbage Collection}

As introduced before (see \autoref{sec:introduction}) the process of garbage
collection is required by many programming languages via their specification,
as is the case with \textit{Java} \cite[Chapter 1.
Introduction]{java_language_spec_2023} and \textit{Go}
\cite[Introduction]{go_spec_2023}. The \textit{Go} programming language
specification however does not include specifics around the implementation of
its garbage collection \cite[Introduction]{go_gcguide_2022}. The \textit{Go}
standard tool chain provides a runtime library included in all executables
created by the \textit{Go} compiler. This library contains the garbage
collector \cite[Introduction]{go_gcguide_2022}.

Garbage collection as a whole is an umbrella term for
different concepts, algorithms and ideas. This chapter includes the
differentiation between these and thereby introduces terms necessary for
understanding the following chapters. 

\section{Scope}
\label{sec:scope}

The scope of garbage collection refers to the variables, resources and memory
areas it manages. Garbage collection is generally responsible for managing
already allocated memory, either by the programmer or the libraries /
subroutines the programmer uses \cite[Abstract]{learned-gc_2020}. The
aforementioned can be cumulated to heap allocated memory or dynamically
allocated memory. This represents the purview of a garbage collector \cite[1
Introduction]{age-based-gc_1999}. The listing \autoref{code:java_gc_variables}
showcases variables that will be garbage collected upon the scope of the
\texttt{GarbageCollected.main()} function ends.

\begin{listing}[H] 
    \begin{minted}{java} 
class GarbageCollected {
    public static void main(String[] args) {
        var test1 = new Test();
        var test2 = new Test();
    }
    public Test() {}
}
    \end{minted}
    \caption{Java variables managed by the garbage collector}
    \label{code:java_gc_variables}
\end{listing}

The areas not managed by the garbage collector and thus not in the scope of
this paper are open resources requiring being closed by the consumer (such as
sockets or \texttt{java.util.Scanner} \cite[close]{java-util-scanner}) and
stack allocated variables as well as statically allocated variables. The
listing \autoref{code:java_non_gc_variables} displays a variety of variables
not garbage collected due to all of them being stack allocated primitive types
\cite[4.2. Primitive Types and Values]{java_language_spec_2023}.

\begin{listing}[H] 
    \begin{minted}{java} 
class NotGarbageCollected {
    static int integer = 5;
    public static void main(String[] args) {
        byte newline = 0x1A;
        double pi = 3.1415;
        char a = 'a';
    }
}
    \end{minted}
    \caption{Java variables not managed by the garbage collector}
    \label{code:java_non_gc_variables}
\end{listing}

\section{Strategies}

Garbage collection can be implemented using a variety of strategies, each
differing in their code complexity, RAM/CPU usage and execution speed.

\subsection{Tracing}

% TODO: cite
Most commonly the term garbage collection is used to refer to tracing garbage
collection. This strategy of automatically managing memory is a common way of
implementing garbage collection.

% TODO: cite
Tracing is defined as determining which objects should be deallocated. This is
done by tracing which of the currently allocated objects are accessible via
linked references. Accessible objects are marked as alive.

Memory regions not accessible via this list are not marked and therefore
considered to be unused memory and are deallocated.

\subsubsection{Categorizing memory}

% TODO: cite
Objects are categorised as reachable or alive if they are referenced by at
least one variable in the currently running program, see
\autoref{code:java_memory_categories_example} for a visualisation. This includes
references from other reachable objects. As introduced before, the definition
of tracing garbage collection includes determining whether or not objects are
reachable. In the paragraph above, this reachability is defined. This
definition does not include the objects the tracing garbage collector refers to
as \textit{root}-objects. root-objects are defined as generally accessible,
such as local variables, parameters and global variables.\footnote{As
introduced in \autoref{sec:scope}: variables on the call stack or static
variables} Root-objects are used as a starting point for tracing allocated
objects.

\begin{listing}[H] 
    \begin{minted}{Java} 
public class Main {
    public static void main(String[] args) {
        var x = new Object();
        x = new Object();
        var y = new Object();
        y = new Object();
        Main.f();
    }

    private static void f() {
        var z = new Object();
    }
}
    \end{minted}
    \caption{Java example for accessible and inaccessible memory}
    \label{code:java_memory_categories_example}
\end{listing}

In \autoref{code:java_memory_categories_example}, both initially to \texttt{x}
and \texttt{y} assigned values in the \texttt{Main.main} function are
considered inaccessible due to the reassignment in the following lines. The
value of the variable \texttt{z} in the \texttt{Main.f} function is considered
inaccessible once the scope of the function ends, thus the variable \texttt{z}
is dropped from the call stack - rendering its value inaccessible. 


\subsubsection{Implementations}
\paragraph{Mark and Sweep}
\paragraph{Generational}
\paragraph{Stop the world}
\subsubsection{Performance}

\subsection{Reference Counting}
\subsection{Escape Analysis}
